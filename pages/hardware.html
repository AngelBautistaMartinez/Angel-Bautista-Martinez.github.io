<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hardware Detection - Angel Code</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000000;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
        }

        .header {
            background-color: #000000;
            padding: 30px 20px;
            text-align: center;
            border-bottom: 3px solid #1a1a1a;
        }

        .back-button {
            display: inline-block;
            background-color: #dc143c;
            color: #ffffff;
            padding: 10px 25px;
            border-radius: 5px;
            text-decoration: none;
            margin-bottom: 20px;
            transition: background-color 0.3s ease;
        }

        .back-button:hover {
            background-color: #b01030;
        }

        .page-title {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 3px;
            margin-top: 10px;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        h3 {
            color: #dc143c;
            font-size: 1.5em;
            margin-top: 50px;
            margin-bottom: 20px;
            font-weight: 400;
        }

        .explanation {
            background-color: #1a1a1a;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #dc143c;
        }

        .explanation p {
            margin-bottom: 15px;
            font-size: 1.05em;
            line-height: 1.8;
        }

        .explanation p:last-child {
            margin-bottom: 0;
        }

        .code-section {
            margin-bottom: 40px;
        }

        .code-label {
            color: #ffffff;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 10px;
            display: block;
        }

        pre {
            background-color: #1a1a1a;
            border: 1px solid #333333;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin-bottom: 30px;
        }

        code {
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.95em;
        }

        .inline-code {
            background-color: #1a1a1a;
            color: #ce9178;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="../index.html" class="back-button">← Back to Home</a>
        <div class="page-title">Hardware Detection</div>
    </div>

    <div class="container">
        <h3>1. Checking Disk Space</h3>

        <div class="explanation">
            <p>Checks the total GB on the host's disk, relying on the fact that most VMs don't have a lot of hardware and space allocated. This checks if the disk's GB surpasses 100 GB - most VMs have 20-100 GB allocated.</p>
        </div>

        <div class="code-section">
            <span class="code-label">C/C++ Code</span>
            <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

int checkDisk(){
    //to hold space for disk info we are going to recive (64bit to hold large numbers)
    ULARGE_INTEGER totalNumberOfBytes;

    if(GetDiskFreeSpaceExW(
        L"C:\\",
        NULL,
        &totalNumberOfBytes,
        NULL
    )){
        //convert bytes to GB
        double totalGB = (double)totalNumberOfBytes.QuadPart / (1024.0 * 1024.0 * 1024.0);        

        if(totalGB&lt;101){
            //Likely VM
            exit(0);
        }
        else if(totalGB&gt;101){
            //Not a VM
            return 0;
        }
    }
    else{
        printf("\nFailed to get disk information\n");
    }
}

int main(){
    if (checkDisk() == 0){
        printf("Carry on, not a VM\n");
    }
    else {
        printf("!!!VM!!!");
    }
    return 0;
}</code></pre>
        </div>

        <h3>2. Checking Number of Processors</h3>

        <div class="explanation">
            <p>This checks the number of processors that the host has. Limited hardware will require that a VM has limited hardware, so it will check if the host has fewer than 3 processors. If it does, it will return as 1. If it has more (which VMs whose host has a lot of hardware can bypass), it will just display the number of processors there are.</p>
        </div>

        <div class="code-section">
            <span class="code-label">C/C++ Code</span>
            <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

int checkProcessers(){
    //struc holds sysinfo hardware info
    SYSTEM_INFO sysInfo;

    GetSystemInfo(&sysInfo);

    printf("Number of processors: %lu\n", sysInfo.dwNumberOfProcessors);
    if(sysInfo.dwNumberOfProcessors &lt; 3){
        printf("\nLikely a VM\n");
        
        exit(1);
    }
    return 0;
}

int main(){
    checkProcessers();
    return 0;
}</code></pre>
        </div>

        <h3>3. Checking Amount of Memory</h3>

        <div class="explanation">
            <p>This is similar to other hardware techniques which will check if there is little hardware assigned to the host (which in most cases there is, except if it's specifically for VM). It checks the amount of memory the "host" has. If it has little memory, it will flag it as likely a VM; if not, it will be set as normal memory.</p>
        </div>

        <div class="code-section">
            <span class="code-label">C/C++ Code</span>
            <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

void checkMemory(){
    //struc that holds memory info
    MEMORYSTATUSEX memInfo;

    //give windows the buffer
    memInfo.dwLength = sizeof(MEMORYSTATUSEX);
    //gets current memory stats
    //Values are in bytes, so we divide by 1024³ to get GB
    if(GlobalMemoryStatusEx(&memInfo)){
        //4ULL = LL = long long(64-bit) to hold the big number of mem
        if(memInfo.ullTotalPhys &lt; (4ULL * 1024 * 1024 * 1024)){
            printf("\nLow memory, likely VM\n");
        }
        else{
            printf("Normal Memory\n");
        }
    }
}

int main(){
    checkMemory();
    return 0;
}</code></pre>
        </div>

        <h3>4. Checking Virtual Hard Disk Boot</h3>

        <div class="explanation">
            <p>If IsNativeVhdBoot doesn't return 0, the system was booted from a virtual hard disk, which indicates a VM. Note that the IsNativeVhdBoot function is effective only on Windows 8 and above. So we can check this function in the kernel32 library and see if it's on or off.</p>
        </div>

        <div class="code-section">
            <span class="code-label">C/C++ Code</span>
            <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

typedef BOOL (WINAPI *ISNATIVEVHDBOOT)(PBOOL);

int checkVDHBoot(){
    //we get a handle to the loaded DLL (kernel32.dll) where IsNativeVhdBoot
    HMODULE hKernel32 = GetModuleHandleA("kernel32.dll");

    if(!hKernel32){
        return -1;
    }
    //use GetProcAddr to find the VHD boot function in kernel32
    ISNATIVEVHDBOOT pIsNativeVhdBoot = (ISNATIVEVHDBOOT)GetProcAddress(hKernel32, "IsNativeVhdBoot");

    //if VHD boot function dosen't exists (older Windows dont have it)
    if(!pIsNativeVhdBoot){
        return -1;
    }
    //set up boolean
    BOOL isVhd = FALSE;
    //if the function successeds AND the boolean value turns 1(true)
    if(pIsNativeVhdBoot(&isVhd) && isVhd){
        return 1;
    }

    return 0;
}

int main(){

    if(checkVDHBoot() == 1){
        printf("Host Booted up from Virt Hard Disk!\n");
    }
    else if(checkVDHBoot() == 0){
        printf("Host didn't boot from Virt Hard Disk\n");
    }
    return 0;
}</code></pre>
        </div>

        <h3>5. Checking Devices</h3>

        <div class="explanation">
            <p>Malware can check devices to see if anything stands out of the usual, like VM names or "Virtual" or "Sandbox".</p>
        </div>

        <div class="code-section">
            <span class="code-label">C/C++ Code</span>
            <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include &lt;setupapi.h&gt;
#include &lt;wchar.h&gt;
#include &lt;initguid.h&gt;
#include &lt;devguid.h&gt;

static void SearchDevices(const GUID *classGuid, LPCWSTR label, BOOL useInterface){
    //flag that only shows devices when connected 
    DWORD flags = DIGCF_PRESENT;
    
    
    //handle to dev info set 
    
    HDEVINFO hDevInfo = SetupDiGetClassDevsW(classGuid, NULL, NULL, flags);
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        wprintf(L"Failed to get device info for %s (Error: %lu)\n", label, GetLastError());
        return;
    }

    //struct that holds info abt a dev
    SP_DEVINFO_DATA devInfo;
    //set size
    devInfo.cbSize = sizeof(SP_DEVINFO_DATA);

    wprintf(L"\n=== %s ===\n", label);
    int count = 0;

    //while we're able to see devices
    for(DWORD i = 0; SetupDiEnumDeviceInfo(hDevInfo, i, &devInfo); i++){
        wchar_t buffer[512];
        
        wprintf(L"\nDevice #%d:\n", ++count);

        
        if(SetupDiGetDeviceRegistryPropertyW(hDevInfo, &devInfo, SPDRP_DEVICEDESC, NULL, (PBYTE)buffer, sizeof(buffer), NULL)){
            wprintf(L"  Description: %s\n", buffer);
        }

        //SPDRP_MFG = manufacturer property
        if(SetupDiGetDeviceRegistryPropertyW(hDevInfo, &devInfo, SPDRP_MFG, NULL, (PBYTE)buffer, sizeof(buffer), NULL)){
            wprintf(L"  Manufacturer: %s\n", buffer);
        }
        //SPDRP_HARDWAREID = hardware ID property
        if(SetupDiGetDeviceRegistryPropertyW(hDevInfo, &devInfo, SPDRP_HARDWAREID, NULL, (PBYTE)buffer, sizeof(buffer), NULL)){
            wprintf(L"  Hardware ID: %s\n", buffer);
        }

    }

    if(count == 0){
        wprintf(L"  No devices found\n");
    }

    SetupDiDestroyDeviceInfoList(hDevInfo);
}

int main(void) {
    SearchDevices(&GUID_DEVCLASS_DISKDRIVE, L"Disk Drives", FALSE);
    SearchDevices(&GUID_DEVCLASS_NET, L"Network Adapters", FALSE);
    SearchDevices(&GUID_DEVCLASS_DISPLAY, L"Display Adapters", FALSE);
    SearchDevices(&GUID_DEVCLASS_MOUSE, L"Mouse Devices", FALSE);
    SearchDevices(&GUID_DEVCLASS_KEYBOARD, L"Keyboard Devices", FALSE);
    SearchDevices(&GUID_DEVCLASS_USB, L"USB Devices", FALSE);

    return 0;
}</code></pre>
        </div>

        <h3>6. Checking CPUID Hypervisor Name</h3>

        <div class="explanation">
            <p>cpuid returns info about the host processors (features and manufacturer). Outside of a VM, executing cpuid with EAX set to 0 will return something like GenuineIntel for Intel processors or AuthenticAMD for AMD processors. When cpuid is executed inside a VM, it often returns the name of the hypervisor. In the case of VMware, this string is VMwareVMware. For VirtualBox, the returned string is VBoxVBoxVBox, so we can use __cpuid to get the CPU name and compare it to VM CPU names to see if they match and therefore indicate a VM CPU.</p>
        </div>

        <div class="code-section">
            <span class="code-label">C/C++ Code</span>
            <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;cpuid.h&gt;
#include &lt;shlwapi.h&gt;

char *VMCPUNames[] = {
    "VMwareVMware",
    "VBoxVBoxVBox",
    "Microsoft Hv",
    "XenVMMXenVMM",
    "QEMUQEMU",
    "VRTUALVRTUAL",
    "TCGTCGTCG"

};

int checkCPUIDName(){
    unsigned int eax, ebx, ecx, edx;
    char name[13];

    __cpuid(0,eax,ebx,ecx,edx);

    *(unsigned int*)&name[0] = ebx;
    *(unsigned int*)&name[4] = edx;
    *(unsigned int*)&name[8] = ecx;
    name[12] = '\0';

    printf("%s\n", name);
    for(int i = 0; i &lt; sizeof(VMCPUNames) / sizeof(VMCPUNames[0]); i++){
        if(StrStrI(name, VMCPUNames[i]) != NULL){
            //match VM CPU found
            exit(1);
        }
    }
    return 0;

}

int main(){
    if(checkCPUIDName() == 0){
        printf("No VM CPU found\n");
    }
    else{
        printf("VM CPU found\n");
    }
    return 0;
}</code></pre>
        </div>

        <h3>7. Checking CPUID Hypervisor Bit</h3>

        <div class="explanation">
            <p>Setting EAX to 1 when using cpuid returns much more information, stored as a 31-bit block in the ECX and EDX registers. The 31st bit in the ECX register will be 0 if the system's CPU is physical or 1 if the system is using a virtual CPU. We can check the number to determine if the program is in a VM.</p>
        </div>

        <div class="code-section">
            <span class="code-label">C/C++ Code</span>
            <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;cpuid.h&gt;

int checkCPUIDHyperBit(){
    //__cpuid writes directly to registors so we have to set it up to 
    //collect all the data the function gives us
    unsigned int eax, ebx, ecx, edx;
    
    //tell __cpuid what info is needed so we pass 1 which means feature flags
    __cpuid(1,eax,ebx,ecx,edx);
    /*
    eax=processor signature
    ebx = brand
    ecx = feature flags &lt;- where the hypervisor bit is
    edx = more feature flags
    */
    //bit 31 in ecx is hypervisor 0=off 1=on
    if(ecx & (1 &lt;&lt; 31)){
        printf("Hypervisor bit set!\n");
        return(0);
    }
    return 0;
}

int main(){
    if(checkCPUIDHyperBit() == 0){
        printf("No VM\n");
    } else{
        printf("VM\n");
    }
    return 0;
}</code></pre>
        </div>

        <h3>8. Checking Rdtsc</h3>

        <div class="explanation">
            <p>VMs have a problem with the rdtsc instruction. When rdtsc is executed by a program running on a virtual processor, the virtual processor must pass this instruction on to the "real" processor - the hardware CPU that runs the host OS. Passing the rdtsc instruction to the real CPU and back again causes some latency, which in turn increases the number of ticks. When malware sees that this returned tick count is higher than it would be on a non-virtualized system, it might detect a VM.</p>
            <p>The CPU on the host might not support the __cpuid asm instruction as it was recently added and may not be an option in the CPU.</p>
        </div>

        <div class="code-section">
            <span class="code-label">C/C++ Code</span>
            <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;intrin.h&gt;
#include &lt;inttypes.h&gt;

//works for 32 and 64 bit
unsigned long long checkTSC(){
    return __rdtsc();
}

unsigned int checkCPUMHz(){
    int cpuInfo[4] = {0};
    /*
    cpuInfo[0] = EAX
    cpuInfo[1] = EBX
    cpuInfo[2] = ECX
    cpuInfo[3] = EDX
    */
    //ask CPU for information about itself we pass where to put the info and also we tell it we
    //want 0x16 which is EAX=0x16 when calling this function which is where the CPU info is at(the hertzs)
    __cpuid(cpuInfo, 0x16);
    
    if(cpuInfo[0] != 0){
        return cpuInfo[0];
    }
    else{
        printf("CPU doesn't fully support __cpuid\n");
        return 0;
        
    }
}

int checkRDTSC(){
    int sleepNumber = 1000;
    unsigned long long start = checkTSC();

    Sleep(sleepNumber);
    //ps use long long cuz the # of ticks are a large #
    unsigned long long end = checkTSC();

    unsigned long long final = end - start;

    unsigned int MHz = checkCPUMHz();

    

    if(MHz &gt; 0){
        unsigned long long expected = (unsigned long long)MHz * 1000000ULL * sleepNumber / 1000ULL;
        unsigned long long lower = expected / 2;
        unsigned long long higher = expected * 2;
        printf("Measured %llu cycles Expected %llu\n", final, expected);
        

        if(final&lt;lower || final&gt;higher){
            //vm
            return 1;
        }
        else{
            //not vm
            return 0;
        }
    }
    if(MHz == 0){
        return 3;
    }
    
    
    

}

int main(){
    if(checkRDTSC() == 0){
        printf("Not VM");
    }
    else if(checkRDTSC() == 1){
        printf("!!VM!!");
    }
}</code></pre>
        </div>

    </div>

    <script>
        hljs.highlightAll();
    </script>
</body>
</html>
